var CSSTranslator = require("../css/translator").CSSTranslator;

var nodes = require("../nodes");

ometa BOSSTranslator <: CSSTranslator {

  any = before
      | ident
      | atkeyword
      | string
      | shash
      | vhash
      | number
      | percentage
      | dimension
      | cdo
      | cdc
      | decldelim
      | s
      | attrselector
      | attrib
      | nth
      | nthselector
      | namespace
      | clazz
      | pseudoe
      | pseudoc
      | delim
      | stylesheet
      | atruleb
      | atrules
      | atrulerq
      | atrulers
      | atruler
      | block
      | ruleset
      | combinator
      | simpleselector
      | selector
      | declaration
      | property
      | important
      | binary
      | unary
      | operator
      | braces
      | value
      | progid
      | filterv
      | filter
      | comment
      | uri
      | raw
      | functionBody
      | funktion
      | functionExpression
      | definition
      | assignment
      | variable
      | after,

  assignment = ['assignment' any:x any:y] -> new nodes.Ident(x.trim(), y),

  clazz = ['clazz' any:x] -> '.' + x,

  vhash = ['vhash' :x] -> new nodes.Color(x),

  dimension = ['dimension' any:x any:y] -> new nodes.Dimension(x, y),

  percentage = ['percentage' any:x] -> new nodes.Dimension(x, '%'),

  number = ['number' :x] -> new nodes.Dimension(x),

  funktion = ['funktion' any:x any:y] -> new nodes.Call(x, y),

  definition = ['definition' any:x any:y any:z] -> new nodes.Definition(x.name, y, z),

  binary = ['binary' any:o any:x any:y] -> new nodes.BinOp(o, x, y),

  unary = ['unary' any:o any:x] -> x.operate('*', new nodes.Dimension(o + 1)),

  variable = ['variable' any:x] -> x,

  comment = ['comment' :x] -> new nodes.Comment(x),

  string = ['string' :x :y] -> new nodes.String(x, y),

  raw = ['raw' :x] -> new nodes.Literal(x),

  uri = ['uri' any:x] -> new nodes.Call('url', new nodes.Arguments(false, [x])),

  stylesheet = ['stylesheet' anys:x] -> new nodes.Stylesheet(x),

  block = ['block' anys:x] -> new nodes.Block(x),

  declaration = ['declaration' any:p any:v] -> new nodes.Declaration(p, v),

  simpleselector = ['simpleselector' anys:x] -> new nodes.Selector(x),

  selector = ['selector' anys:x] -> x.filter(function (selector) { return selector !== ',' }),

  ruleset = ['ruleset' any:x any:y] -> new nodes.Ruleset(x, y),

  ident = ['ident' :x] -> new nodes.Ident(x),

  pseudoe = ['pseudoe' any:x] -> '::' + x,

  pseudoc = ['pseudoc' any:x] -> ':' + x,

  value = ['value' anys:x] -> createExpression(x),

  functionBody = ['functionBody' anys:x] -> createExpression(x, true),

  operator = ['operator' :x] -> new nodes.Literal(x),

  important = ['important'] -> new nodes.Literal('!important'),

  atruler = ['atruler' any:x any:y any:z] -> new nodes.Atrule(x + y, z),

  atrulers = ['atrulers' anys:x] -> new nodes.Block(x),

  atrules = ['atrules' anys:x] -> new nodes.Atrule(x.join('')),

  progid = ['progid' any:x] -> x,

  filter = ['filter' any:p any:v] -> new nodes.Declaration(p, v),

  filterv = ['filterv' any:x] -> x,

}

var createExpression = function (x, isArgs) {
  var ctor = isArgs ? 'Arguments' : 'Expression',
      expr = new nodes[ctor],
      list = isArgs ? new nodes[ctor](true) : undefined;

  x.forEach(function (node) {
    if (node.value === ',') {
      list = list || new nodes[ctor](true);
      list.push(expr);
      expr = new nodes.Expression;
      return;
    }
    expr.push(node);
  })

  list && list.push(expr);

  return list || expr;
}